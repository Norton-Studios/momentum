/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client";
import type * as Prisma from "../models";
import { type PrismaClient } from "./class";

export type * from "../models";

export type DMMF = typeof runtime.DMMF;

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>;

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError;
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError;

export const PrismaClientValidationError = runtime.PrismaClientValidationError;
export type PrismaClientValidationError = runtime.PrismaClientValidationError;

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag;
export const empty = runtime.empty;
export const join = runtime.join;
export const raw = runtime.raw;
export const Sql = runtime.Sql;
export type Sql = runtime.Sql;

/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal;
export type Decimal = runtime.Decimal;

export type DecimalJsLike = runtime.DecimalJsLike;

/**
 * Extensions
 */
export type Extension = runtime.Types.Extensions.UserArgs;
export const getExtensionContext = runtime.Extensions.getExtensionContext;
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>;
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>;
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>;
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>;

export type PrismaVersion = {
  client: string;
  engine: string;
};

/**
 * Prisma Client JS version: 7.1.0
 * Query Engine version: ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba
 */
export const prismaVersion: PrismaVersion = {
  client: "7.1.0",
  engine: "ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba",
};

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes;
export type JsonObject = runtime.JsonObject;
export type JsonArray = runtime.JsonArray;
export type JsonValue = runtime.JsonValue;
export type InputJsonObject = runtime.InputJsonObject;
export type InputJsonArray = runtime.InputJsonArray;
export type InputJsonValue = runtime.InputJsonValue;

export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as new (secret: never) => typeof runtime.DbNull,
  JsonNull: runtime.NullTypes.JsonNull as new (secret: never) => typeof runtime.JsonNull,
  AnyNull: runtime.NullTypes.AnyNull as new (secret: never) => typeof runtime.AnyNull,
};
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull;

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull;

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull;

type SelectAndInclude = {
  select: any;
  include: any;
};

type SelectAndOmit = {
  select: any;
  omit: any;
};

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
} & (T extends SelectAndInclude ? "Please either choose `select` or `include`." : T extends SelectAndOmit ? "Please either choose `select` or `omit`." : {});

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
} & K;

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> = T extends object ? (U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : U) : T;

/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any> ? False : T extends Date ? False : T extends Uint8Array ? False : T extends BigInt ? False : T extends object ? True : False;

/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
  }[K];

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

type _Either<O extends object, K extends Key, strict extends Boolean> = {
  1: EitherStrict<O, K>;
  0: EitherLoose<O, K>;
}[strict];

export type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown ? _Either<O, K, strict> : never;

export type Union = any;

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
} & {};

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (k: infer I) => void ? I : never;

export type Overwrite<O extends object, O1 extends object> = {
  [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<
  Overwrite<
    U,
    {
      [K in keyof U]-?: At<U, K>;
    }
  >
>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
  1: AtStrict<O, K>;
  0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function
  ? A
  : {
      [K in keyof A]: A[K];
    } & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown ? (K extends keyof O ? { [P in K]: O[P] } & O : O) | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O) : never
>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False;

export type True = 1;

export type False = 0;

export type Not<B extends Boolean> = {
  0: 1;
  1: 0;
}[B];

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
    ? 1
    : 0;

export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0;
    1: 1;
  };
  1: {
    0: 1;
    1: 1;
  };
}[B1][B2];

export type Keys<U extends Union> = U extends unknown ? keyof U : never;

export type GetScalarType<T, O> = O extends object
  ? {
      [P in keyof T]: P extends keyof O ? O[P] : never;
    }
  : never;

type FieldPaths<T, U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">> = IsObject<T> extends True ? U : T;

export type GetHavingFields<T> = {
  [K in keyof T]: Or<Or<Extends<"OR", K>, Extends<"AND", K>>, Extends<"NOT", K>> extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
      ? never
      : K;
}[keyof T];

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>;

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T;

export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>;

export const ModelName = {
  User: "User",
  Organization: "Organization",
  Team: "Team",
  TeamRepository: "TeamRepository",
  TeamProject: "TeamProject",
  Repository: "Repository",
  Contributor: "Contributor",
  Commit: "Commit",
  PullRequest: "PullRequest",
  PullRequestReview: "PullRequestReview",
  Pipeline: "Pipeline",
  PipelineRun: "PipelineRun",
  PipelineStage: "PipelineStage",
  QualityScan: "QualityScan",
  CoverageMetric: "CoverageMetric",
  SecurityVulnerability: "SecurityVulnerability",
  SonarQubeProjectMapping: "SonarQubeProjectMapping",
  Project: "Project",
  Board: "Board",
  Sprint: "Sprint",
  Issue: "Issue",
  IssueStatusTransition: "IssueStatusTransition",
  DataSource: "DataSource",
  DataSourceConfig: "DataSourceConfig",
  ImportBatch: "ImportBatch",
  DataSourceRun: "DataSourceRun",
  ImportLog: "ImportLog",
} as const;

export type ModelName = (typeof ModelName)[keyof typeof ModelName];

export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{ extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this["params"]["extArgs"], GlobalOmitOptions>;
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions;
  };
  meta: {
    modelProps:
      | "user"
      | "organization"
      | "team"
      | "teamRepository"
      | "teamProject"
      | "repository"
      | "contributor"
      | "commit"
      | "pullRequest"
      | "pullRequestReview"
      | "pipeline"
      | "pipelineRun"
      | "pipelineStage"
      | "qualityScan"
      | "coverageMetric"
      | "securityVulnerability"
      | "sonarQubeProjectMapping"
      | "project"
      | "board"
      | "sprint"
      | "issue"
      | "issueStatusTransition"
      | "dataSource"
      | "dataSourceConfig"
      | "importBatch"
      | "dataSourceRun"
      | "importLog";
    txIsolationLevel: TransactionIsolationLevel;
  };
  model: {
    User: {
      payload: Prisma.$UserPayload<ExtArgs>;
      fields: Prisma.UserFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
        };
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
        };
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
        };
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>;
        };
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[];
        };
        count: {
          args: Prisma.UserCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number;
        };
      };
    };
    Organization: {
      payload: Prisma.$OrganizationPayload<ExtArgs>;
      fields: Prisma.OrganizationFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.OrganizationFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>;
        };
        findFirst: {
          args: Prisma.OrganizationFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>;
        };
        findMany: {
          args: Prisma.OrganizationFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[];
        };
        create: {
          args: Prisma.OrganizationCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>;
        };
        createMany: {
          args: Prisma.OrganizationCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[];
        };
        delete: {
          args: Prisma.OrganizationDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>;
        };
        update: {
          args: Prisma.OrganizationUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>;
        };
        deleteMany: {
          args: Prisma.OrganizationDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.OrganizationUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[];
        };
        upsert: {
          args: Prisma.OrganizationUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>;
        };
        aggregate: {
          args: Prisma.OrganizationAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganization>;
        };
        groupBy: {
          args: Prisma.OrganizationGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.OrganizationGroupByOutputType>[];
        };
        count: {
          args: Prisma.OrganizationCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.OrganizationCountAggregateOutputType> | number;
        };
      };
    };
    Team: {
      payload: Prisma.$TeamPayload<ExtArgs>;
      fields: Prisma.TeamFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TeamFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
        };
        findFirst: {
          args: Prisma.TeamFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
        };
        findMany: {
          args: Prisma.TeamFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>[];
        };
        create: {
          args: Prisma.TeamCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
        };
        createMany: {
          args: Prisma.TeamCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>[];
        };
        delete: {
          args: Prisma.TeamDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
        };
        update: {
          args: Prisma.TeamUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
        };
        deleteMany: {
          args: Prisma.TeamDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TeamUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>[];
        };
        upsert: {
          args: Prisma.TeamUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
        };
        aggregate: {
          args: Prisma.TeamAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTeam>;
        };
        groupBy: {
          args: Prisma.TeamGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TeamGroupByOutputType>[];
        };
        count: {
          args: Prisma.TeamCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TeamCountAggregateOutputType> | number;
        };
      };
    };
    TeamRepository: {
      payload: Prisma.$TeamRepositoryPayload<ExtArgs>;
      fields: Prisma.TeamRepositoryFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TeamRepositoryFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamRepositoryPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TeamRepositoryFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamRepositoryPayload>;
        };
        findFirst: {
          args: Prisma.TeamRepositoryFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamRepositoryPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TeamRepositoryFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamRepositoryPayload>;
        };
        findMany: {
          args: Prisma.TeamRepositoryFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamRepositoryPayload>[];
        };
        create: {
          args: Prisma.TeamRepositoryCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamRepositoryPayload>;
        };
        createMany: {
          args: Prisma.TeamRepositoryCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.TeamRepositoryCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamRepositoryPayload>[];
        };
        delete: {
          args: Prisma.TeamRepositoryDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamRepositoryPayload>;
        };
        update: {
          args: Prisma.TeamRepositoryUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamRepositoryPayload>;
        };
        deleteMany: {
          args: Prisma.TeamRepositoryDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TeamRepositoryUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.TeamRepositoryUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamRepositoryPayload>[];
        };
        upsert: {
          args: Prisma.TeamRepositoryUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamRepositoryPayload>;
        };
        aggregate: {
          args: Prisma.TeamRepositoryAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTeamRepository>;
        };
        groupBy: {
          args: Prisma.TeamRepositoryGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TeamRepositoryGroupByOutputType>[];
        };
        count: {
          args: Prisma.TeamRepositoryCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TeamRepositoryCountAggregateOutputType> | number;
        };
      };
    };
    TeamProject: {
      payload: Prisma.$TeamProjectPayload<ExtArgs>;
      fields: Prisma.TeamProjectFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TeamProjectFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamProjectPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TeamProjectFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamProjectPayload>;
        };
        findFirst: {
          args: Prisma.TeamProjectFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamProjectPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TeamProjectFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamProjectPayload>;
        };
        findMany: {
          args: Prisma.TeamProjectFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamProjectPayload>[];
        };
        create: {
          args: Prisma.TeamProjectCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamProjectPayload>;
        };
        createMany: {
          args: Prisma.TeamProjectCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.TeamProjectCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamProjectPayload>[];
        };
        delete: {
          args: Prisma.TeamProjectDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamProjectPayload>;
        };
        update: {
          args: Prisma.TeamProjectUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamProjectPayload>;
        };
        deleteMany: {
          args: Prisma.TeamProjectDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TeamProjectUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.TeamProjectUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamProjectPayload>[];
        };
        upsert: {
          args: Prisma.TeamProjectUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamProjectPayload>;
        };
        aggregate: {
          args: Prisma.TeamProjectAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTeamProject>;
        };
        groupBy: {
          args: Prisma.TeamProjectGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TeamProjectGroupByOutputType>[];
        };
        count: {
          args: Prisma.TeamProjectCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TeamProjectCountAggregateOutputType> | number;
        };
      };
    };
    Repository: {
      payload: Prisma.$RepositoryPayload<ExtArgs>;
      fields: Prisma.RepositoryFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.RepositoryFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RepositoryPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.RepositoryFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RepositoryPayload>;
        };
        findFirst: {
          args: Prisma.RepositoryFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RepositoryPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.RepositoryFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RepositoryPayload>;
        };
        findMany: {
          args: Prisma.RepositoryFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RepositoryPayload>[];
        };
        create: {
          args: Prisma.RepositoryCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RepositoryPayload>;
        };
        createMany: {
          args: Prisma.RepositoryCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.RepositoryCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RepositoryPayload>[];
        };
        delete: {
          args: Prisma.RepositoryDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RepositoryPayload>;
        };
        update: {
          args: Prisma.RepositoryUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RepositoryPayload>;
        };
        deleteMany: {
          args: Prisma.RepositoryDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.RepositoryUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.RepositoryUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RepositoryPayload>[];
        };
        upsert: {
          args: Prisma.RepositoryUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RepositoryPayload>;
        };
        aggregate: {
          args: Prisma.RepositoryAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateRepository>;
        };
        groupBy: {
          args: Prisma.RepositoryGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.RepositoryGroupByOutputType>[];
        };
        count: {
          args: Prisma.RepositoryCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.RepositoryCountAggregateOutputType> | number;
        };
      };
    };
    Contributor: {
      payload: Prisma.$ContributorPayload<ExtArgs>;
      fields: Prisma.ContributorFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ContributorFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContributorPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ContributorFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContributorPayload>;
        };
        findFirst: {
          args: Prisma.ContributorFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContributorPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ContributorFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContributorPayload>;
        };
        findMany: {
          args: Prisma.ContributorFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContributorPayload>[];
        };
        create: {
          args: Prisma.ContributorCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContributorPayload>;
        };
        createMany: {
          args: Prisma.ContributorCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ContributorCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContributorPayload>[];
        };
        delete: {
          args: Prisma.ContributorDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContributorPayload>;
        };
        update: {
          args: Prisma.ContributorUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContributorPayload>;
        };
        deleteMany: {
          args: Prisma.ContributorDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ContributorUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ContributorUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContributorPayload>[];
        };
        upsert: {
          args: Prisma.ContributorUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContributorPayload>;
        };
        aggregate: {
          args: Prisma.ContributorAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateContributor>;
        };
        groupBy: {
          args: Prisma.ContributorGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ContributorGroupByOutputType>[];
        };
        count: {
          args: Prisma.ContributorCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ContributorCountAggregateOutputType> | number;
        };
      };
    };
    Commit: {
      payload: Prisma.$CommitPayload<ExtArgs>;
      fields: Prisma.CommitFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.CommitFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.CommitFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitPayload>;
        };
        findFirst: {
          args: Prisma.CommitFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.CommitFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitPayload>;
        };
        findMany: {
          args: Prisma.CommitFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitPayload>[];
        };
        create: {
          args: Prisma.CommitCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitPayload>;
        };
        createMany: {
          args: Prisma.CommitCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.CommitCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitPayload>[];
        };
        delete: {
          args: Prisma.CommitDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitPayload>;
        };
        update: {
          args: Prisma.CommitUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitPayload>;
        };
        deleteMany: {
          args: Prisma.CommitDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.CommitUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.CommitUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitPayload>[];
        };
        upsert: {
          args: Prisma.CommitUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitPayload>;
        };
        aggregate: {
          args: Prisma.CommitAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateCommit>;
        };
        groupBy: {
          args: Prisma.CommitGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.CommitGroupByOutputType>[];
        };
        count: {
          args: Prisma.CommitCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.CommitCountAggregateOutputType> | number;
        };
      };
    };
    PullRequest: {
      payload: Prisma.$PullRequestPayload<ExtArgs>;
      fields: Prisma.PullRequestFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.PullRequestFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.PullRequestFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestPayload>;
        };
        findFirst: {
          args: Prisma.PullRequestFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PullRequestFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestPayload>;
        };
        findMany: {
          args: Prisma.PullRequestFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestPayload>[];
        };
        create: {
          args: Prisma.PullRequestCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestPayload>;
        };
        createMany: {
          args: Prisma.PullRequestCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.PullRequestCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestPayload>[];
        };
        delete: {
          args: Prisma.PullRequestDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestPayload>;
        };
        update: {
          args: Prisma.PullRequestUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestPayload>;
        };
        deleteMany: {
          args: Prisma.PullRequestDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.PullRequestUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.PullRequestUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestPayload>[];
        };
        upsert: {
          args: Prisma.PullRequestUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestPayload>;
        };
        aggregate: {
          args: Prisma.PullRequestAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePullRequest>;
        };
        groupBy: {
          args: Prisma.PullRequestGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PullRequestGroupByOutputType>[];
        };
        count: {
          args: Prisma.PullRequestCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PullRequestCountAggregateOutputType> | number;
        };
      };
    };
    PullRequestReview: {
      payload: Prisma.$PullRequestReviewPayload<ExtArgs>;
      fields: Prisma.PullRequestReviewFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.PullRequestReviewFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestReviewPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.PullRequestReviewFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestReviewPayload>;
        };
        findFirst: {
          args: Prisma.PullRequestReviewFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestReviewPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PullRequestReviewFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestReviewPayload>;
        };
        findMany: {
          args: Prisma.PullRequestReviewFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestReviewPayload>[];
        };
        create: {
          args: Prisma.PullRequestReviewCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestReviewPayload>;
        };
        createMany: {
          args: Prisma.PullRequestReviewCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.PullRequestReviewCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestReviewPayload>[];
        };
        delete: {
          args: Prisma.PullRequestReviewDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestReviewPayload>;
        };
        update: {
          args: Prisma.PullRequestReviewUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestReviewPayload>;
        };
        deleteMany: {
          args: Prisma.PullRequestReviewDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.PullRequestReviewUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.PullRequestReviewUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestReviewPayload>[];
        };
        upsert: {
          args: Prisma.PullRequestReviewUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PullRequestReviewPayload>;
        };
        aggregate: {
          args: Prisma.PullRequestReviewAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePullRequestReview>;
        };
        groupBy: {
          args: Prisma.PullRequestReviewGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PullRequestReviewGroupByOutputType>[];
        };
        count: {
          args: Prisma.PullRequestReviewCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PullRequestReviewCountAggregateOutputType> | number;
        };
      };
    };
    Pipeline: {
      payload: Prisma.$PipelinePayload<ExtArgs>;
      fields: Prisma.PipelineFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.PipelineFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelinePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.PipelineFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelinePayload>;
        };
        findFirst: {
          args: Prisma.PipelineFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelinePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PipelineFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelinePayload>;
        };
        findMany: {
          args: Prisma.PipelineFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelinePayload>[];
        };
        create: {
          args: Prisma.PipelineCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelinePayload>;
        };
        createMany: {
          args: Prisma.PipelineCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.PipelineCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelinePayload>[];
        };
        delete: {
          args: Prisma.PipelineDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelinePayload>;
        };
        update: {
          args: Prisma.PipelineUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelinePayload>;
        };
        deleteMany: {
          args: Prisma.PipelineDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.PipelineUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.PipelineUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelinePayload>[];
        };
        upsert: {
          args: Prisma.PipelineUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelinePayload>;
        };
        aggregate: {
          args: Prisma.PipelineAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePipeline>;
        };
        groupBy: {
          args: Prisma.PipelineGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PipelineGroupByOutputType>[];
        };
        count: {
          args: Prisma.PipelineCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PipelineCountAggregateOutputType> | number;
        };
      };
    };
    PipelineRun: {
      payload: Prisma.$PipelineRunPayload<ExtArgs>;
      fields: Prisma.PipelineRunFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.PipelineRunFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineRunPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.PipelineRunFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineRunPayload>;
        };
        findFirst: {
          args: Prisma.PipelineRunFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineRunPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PipelineRunFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineRunPayload>;
        };
        findMany: {
          args: Prisma.PipelineRunFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineRunPayload>[];
        };
        create: {
          args: Prisma.PipelineRunCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineRunPayload>;
        };
        createMany: {
          args: Prisma.PipelineRunCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.PipelineRunCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineRunPayload>[];
        };
        delete: {
          args: Prisma.PipelineRunDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineRunPayload>;
        };
        update: {
          args: Prisma.PipelineRunUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineRunPayload>;
        };
        deleteMany: {
          args: Prisma.PipelineRunDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.PipelineRunUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.PipelineRunUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineRunPayload>[];
        };
        upsert: {
          args: Prisma.PipelineRunUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineRunPayload>;
        };
        aggregate: {
          args: Prisma.PipelineRunAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePipelineRun>;
        };
        groupBy: {
          args: Prisma.PipelineRunGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PipelineRunGroupByOutputType>[];
        };
        count: {
          args: Prisma.PipelineRunCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PipelineRunCountAggregateOutputType> | number;
        };
      };
    };
    PipelineStage: {
      payload: Prisma.$PipelineStagePayload<ExtArgs>;
      fields: Prisma.PipelineStageFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.PipelineStageFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineStagePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.PipelineStageFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineStagePayload>;
        };
        findFirst: {
          args: Prisma.PipelineStageFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineStagePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PipelineStageFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineStagePayload>;
        };
        findMany: {
          args: Prisma.PipelineStageFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineStagePayload>[];
        };
        create: {
          args: Prisma.PipelineStageCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineStagePayload>;
        };
        createMany: {
          args: Prisma.PipelineStageCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.PipelineStageCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineStagePayload>[];
        };
        delete: {
          args: Prisma.PipelineStageDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineStagePayload>;
        };
        update: {
          args: Prisma.PipelineStageUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineStagePayload>;
        };
        deleteMany: {
          args: Prisma.PipelineStageDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.PipelineStageUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.PipelineStageUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineStagePayload>[];
        };
        upsert: {
          args: Prisma.PipelineStageUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PipelineStagePayload>;
        };
        aggregate: {
          args: Prisma.PipelineStageAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePipelineStage>;
        };
        groupBy: {
          args: Prisma.PipelineStageGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PipelineStageGroupByOutputType>[];
        };
        count: {
          args: Prisma.PipelineStageCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PipelineStageCountAggregateOutputType> | number;
        };
      };
    };
    QualityScan: {
      payload: Prisma.$QualityScanPayload<ExtArgs>;
      fields: Prisma.QualityScanFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.QualityScanFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualityScanPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.QualityScanFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualityScanPayload>;
        };
        findFirst: {
          args: Prisma.QualityScanFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualityScanPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.QualityScanFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualityScanPayload>;
        };
        findMany: {
          args: Prisma.QualityScanFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualityScanPayload>[];
        };
        create: {
          args: Prisma.QualityScanCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualityScanPayload>;
        };
        createMany: {
          args: Prisma.QualityScanCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.QualityScanCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualityScanPayload>[];
        };
        delete: {
          args: Prisma.QualityScanDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualityScanPayload>;
        };
        update: {
          args: Prisma.QualityScanUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualityScanPayload>;
        };
        deleteMany: {
          args: Prisma.QualityScanDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.QualityScanUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.QualityScanUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualityScanPayload>[];
        };
        upsert: {
          args: Prisma.QualityScanUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualityScanPayload>;
        };
        aggregate: {
          args: Prisma.QualityScanAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateQualityScan>;
        };
        groupBy: {
          args: Prisma.QualityScanGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.QualityScanGroupByOutputType>[];
        };
        count: {
          args: Prisma.QualityScanCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.QualityScanCountAggregateOutputType> | number;
        };
      };
    };
    CoverageMetric: {
      payload: Prisma.$CoverageMetricPayload<ExtArgs>;
      fields: Prisma.CoverageMetricFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.CoverageMetricFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoverageMetricPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.CoverageMetricFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoverageMetricPayload>;
        };
        findFirst: {
          args: Prisma.CoverageMetricFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoverageMetricPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.CoverageMetricFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoverageMetricPayload>;
        };
        findMany: {
          args: Prisma.CoverageMetricFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoverageMetricPayload>[];
        };
        create: {
          args: Prisma.CoverageMetricCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoverageMetricPayload>;
        };
        createMany: {
          args: Prisma.CoverageMetricCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.CoverageMetricCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoverageMetricPayload>[];
        };
        delete: {
          args: Prisma.CoverageMetricDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoverageMetricPayload>;
        };
        update: {
          args: Prisma.CoverageMetricUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoverageMetricPayload>;
        };
        deleteMany: {
          args: Prisma.CoverageMetricDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.CoverageMetricUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.CoverageMetricUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoverageMetricPayload>[];
        };
        upsert: {
          args: Prisma.CoverageMetricUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoverageMetricPayload>;
        };
        aggregate: {
          args: Prisma.CoverageMetricAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateCoverageMetric>;
        };
        groupBy: {
          args: Prisma.CoverageMetricGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.CoverageMetricGroupByOutputType>[];
        };
        count: {
          args: Prisma.CoverageMetricCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.CoverageMetricCountAggregateOutputType> | number;
        };
      };
    };
    SecurityVulnerability: {
      payload: Prisma.$SecurityVulnerabilityPayload<ExtArgs>;
      fields: Prisma.SecurityVulnerabilityFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SecurityVulnerabilityFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecurityVulnerabilityPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SecurityVulnerabilityFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecurityVulnerabilityPayload>;
        };
        findFirst: {
          args: Prisma.SecurityVulnerabilityFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecurityVulnerabilityPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SecurityVulnerabilityFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecurityVulnerabilityPayload>;
        };
        findMany: {
          args: Prisma.SecurityVulnerabilityFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecurityVulnerabilityPayload>[];
        };
        create: {
          args: Prisma.SecurityVulnerabilityCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecurityVulnerabilityPayload>;
        };
        createMany: {
          args: Prisma.SecurityVulnerabilityCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SecurityVulnerabilityCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecurityVulnerabilityPayload>[];
        };
        delete: {
          args: Prisma.SecurityVulnerabilityDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecurityVulnerabilityPayload>;
        };
        update: {
          args: Prisma.SecurityVulnerabilityUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecurityVulnerabilityPayload>;
        };
        deleteMany: {
          args: Prisma.SecurityVulnerabilityDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SecurityVulnerabilityUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SecurityVulnerabilityUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecurityVulnerabilityPayload>[];
        };
        upsert: {
          args: Prisma.SecurityVulnerabilityUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecurityVulnerabilityPayload>;
        };
        aggregate: {
          args: Prisma.SecurityVulnerabilityAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSecurityVulnerability>;
        };
        groupBy: {
          args: Prisma.SecurityVulnerabilityGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SecurityVulnerabilityGroupByOutputType>[];
        };
        count: {
          args: Prisma.SecurityVulnerabilityCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SecurityVulnerabilityCountAggregateOutputType> | number;
        };
      };
    };
    SonarQubeProjectMapping: {
      payload: Prisma.$SonarQubeProjectMappingPayload<ExtArgs>;
      fields: Prisma.SonarQubeProjectMappingFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SonarQubeProjectMappingFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SonarQubeProjectMappingPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SonarQubeProjectMappingFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SonarQubeProjectMappingPayload>;
        };
        findFirst: {
          args: Prisma.SonarQubeProjectMappingFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SonarQubeProjectMappingPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SonarQubeProjectMappingFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SonarQubeProjectMappingPayload>;
        };
        findMany: {
          args: Prisma.SonarQubeProjectMappingFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SonarQubeProjectMappingPayload>[];
        };
        create: {
          args: Prisma.SonarQubeProjectMappingCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SonarQubeProjectMappingPayload>;
        };
        createMany: {
          args: Prisma.SonarQubeProjectMappingCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SonarQubeProjectMappingCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SonarQubeProjectMappingPayload>[];
        };
        delete: {
          args: Prisma.SonarQubeProjectMappingDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SonarQubeProjectMappingPayload>;
        };
        update: {
          args: Prisma.SonarQubeProjectMappingUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SonarQubeProjectMappingPayload>;
        };
        deleteMany: {
          args: Prisma.SonarQubeProjectMappingDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SonarQubeProjectMappingUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SonarQubeProjectMappingUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SonarQubeProjectMappingPayload>[];
        };
        upsert: {
          args: Prisma.SonarQubeProjectMappingUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SonarQubeProjectMappingPayload>;
        };
        aggregate: {
          args: Prisma.SonarQubeProjectMappingAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSonarQubeProjectMapping>;
        };
        groupBy: {
          args: Prisma.SonarQubeProjectMappingGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SonarQubeProjectMappingGroupByOutputType>[];
        };
        count: {
          args: Prisma.SonarQubeProjectMappingCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SonarQubeProjectMappingCountAggregateOutputType> | number;
        };
      };
    };
    Project: {
      payload: Prisma.$ProjectPayload<ExtArgs>;
      fields: Prisma.ProjectFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ProjectFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>;
        };
        findFirst: {
          args: Prisma.ProjectFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>;
        };
        findMany: {
          args: Prisma.ProjectFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[];
        };
        create: {
          args: Prisma.ProjectCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>;
        };
        createMany: {
          args: Prisma.ProjectCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[];
        };
        delete: {
          args: Prisma.ProjectDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>;
        };
        update: {
          args: Prisma.ProjectUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>;
        };
        deleteMany: {
          args: Prisma.ProjectDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ProjectUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[];
        };
        upsert: {
          args: Prisma.ProjectUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>;
        };
        aggregate: {
          args: Prisma.ProjectAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateProject>;
        };
        groupBy: {
          args: Prisma.ProjectGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ProjectGroupByOutputType>[];
        };
        count: {
          args: Prisma.ProjectCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ProjectCountAggregateOutputType> | number;
        };
      };
    };
    Board: {
      payload: Prisma.$BoardPayload<ExtArgs>;
      fields: Prisma.BoardFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.BoardFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.BoardFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardPayload>;
        };
        findFirst: {
          args: Prisma.BoardFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.BoardFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardPayload>;
        };
        findMany: {
          args: Prisma.BoardFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardPayload>[];
        };
        create: {
          args: Prisma.BoardCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardPayload>;
        };
        createMany: {
          args: Prisma.BoardCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.BoardCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardPayload>[];
        };
        delete: {
          args: Prisma.BoardDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardPayload>;
        };
        update: {
          args: Prisma.BoardUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardPayload>;
        };
        deleteMany: {
          args: Prisma.BoardDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.BoardUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.BoardUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardPayload>[];
        };
        upsert: {
          args: Prisma.BoardUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardPayload>;
        };
        aggregate: {
          args: Prisma.BoardAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateBoard>;
        };
        groupBy: {
          args: Prisma.BoardGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.BoardGroupByOutputType>[];
        };
        count: {
          args: Prisma.BoardCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.BoardCountAggregateOutputType> | number;
        };
      };
    };
    Sprint: {
      payload: Prisma.$SprintPayload<ExtArgs>;
      fields: Prisma.SprintFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SprintFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SprintPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SprintFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SprintPayload>;
        };
        findFirst: {
          args: Prisma.SprintFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SprintPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SprintFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SprintPayload>;
        };
        findMany: {
          args: Prisma.SprintFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SprintPayload>[];
        };
        create: {
          args: Prisma.SprintCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SprintPayload>;
        };
        createMany: {
          args: Prisma.SprintCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SprintCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SprintPayload>[];
        };
        delete: {
          args: Prisma.SprintDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SprintPayload>;
        };
        update: {
          args: Prisma.SprintUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SprintPayload>;
        };
        deleteMany: {
          args: Prisma.SprintDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SprintUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SprintUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SprintPayload>[];
        };
        upsert: {
          args: Prisma.SprintUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SprintPayload>;
        };
        aggregate: {
          args: Prisma.SprintAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSprint>;
        };
        groupBy: {
          args: Prisma.SprintGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SprintGroupByOutputType>[];
        };
        count: {
          args: Prisma.SprintCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SprintCountAggregateOutputType> | number;
        };
      };
    };
    Issue: {
      payload: Prisma.$IssuePayload<ExtArgs>;
      fields: Prisma.IssueFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.IssueFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.IssueFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>;
        };
        findFirst: {
          args: Prisma.IssueFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.IssueFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>;
        };
        findMany: {
          args: Prisma.IssueFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>[];
        };
        create: {
          args: Prisma.IssueCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>;
        };
        createMany: {
          args: Prisma.IssueCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.IssueCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>[];
        };
        delete: {
          args: Prisma.IssueDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>;
        };
        update: {
          args: Prisma.IssueUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>;
        };
        deleteMany: {
          args: Prisma.IssueDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.IssueUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.IssueUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>[];
        };
        upsert: {
          args: Prisma.IssueUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>;
        };
        aggregate: {
          args: Prisma.IssueAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateIssue>;
        };
        groupBy: {
          args: Prisma.IssueGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.IssueGroupByOutputType>[];
        };
        count: {
          args: Prisma.IssueCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.IssueCountAggregateOutputType> | number;
        };
      };
    };
    IssueStatusTransition: {
      payload: Prisma.$IssueStatusTransitionPayload<ExtArgs>;
      fields: Prisma.IssueStatusTransitionFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.IssueStatusTransitionFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueStatusTransitionPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.IssueStatusTransitionFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueStatusTransitionPayload>;
        };
        findFirst: {
          args: Prisma.IssueStatusTransitionFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueStatusTransitionPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.IssueStatusTransitionFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueStatusTransitionPayload>;
        };
        findMany: {
          args: Prisma.IssueStatusTransitionFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueStatusTransitionPayload>[];
        };
        create: {
          args: Prisma.IssueStatusTransitionCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueStatusTransitionPayload>;
        };
        createMany: {
          args: Prisma.IssueStatusTransitionCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.IssueStatusTransitionCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueStatusTransitionPayload>[];
        };
        delete: {
          args: Prisma.IssueStatusTransitionDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueStatusTransitionPayload>;
        };
        update: {
          args: Prisma.IssueStatusTransitionUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueStatusTransitionPayload>;
        };
        deleteMany: {
          args: Prisma.IssueStatusTransitionDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.IssueStatusTransitionUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.IssueStatusTransitionUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueStatusTransitionPayload>[];
        };
        upsert: {
          args: Prisma.IssueStatusTransitionUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueStatusTransitionPayload>;
        };
        aggregate: {
          args: Prisma.IssueStatusTransitionAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateIssueStatusTransition>;
        };
        groupBy: {
          args: Prisma.IssueStatusTransitionGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.IssueStatusTransitionGroupByOutputType>[];
        };
        count: {
          args: Prisma.IssueStatusTransitionCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.IssueStatusTransitionCountAggregateOutputType> | number;
        };
      };
    };
    DataSource: {
      payload: Prisma.$DataSourcePayload<ExtArgs>;
      fields: Prisma.DataSourceFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.DataSourceFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourcePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.DataSourceFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourcePayload>;
        };
        findFirst: {
          args: Prisma.DataSourceFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourcePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.DataSourceFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourcePayload>;
        };
        findMany: {
          args: Prisma.DataSourceFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourcePayload>[];
        };
        create: {
          args: Prisma.DataSourceCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourcePayload>;
        };
        createMany: {
          args: Prisma.DataSourceCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.DataSourceCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourcePayload>[];
        };
        delete: {
          args: Prisma.DataSourceDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourcePayload>;
        };
        update: {
          args: Prisma.DataSourceUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourcePayload>;
        };
        deleteMany: {
          args: Prisma.DataSourceDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.DataSourceUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.DataSourceUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourcePayload>[];
        };
        upsert: {
          args: Prisma.DataSourceUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourcePayload>;
        };
        aggregate: {
          args: Prisma.DataSourceAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateDataSource>;
        };
        groupBy: {
          args: Prisma.DataSourceGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.DataSourceGroupByOutputType>[];
        };
        count: {
          args: Prisma.DataSourceCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.DataSourceCountAggregateOutputType> | number;
        };
      };
    };
    DataSourceConfig: {
      payload: Prisma.$DataSourceConfigPayload<ExtArgs>;
      fields: Prisma.DataSourceConfigFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.DataSourceConfigFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceConfigPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.DataSourceConfigFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceConfigPayload>;
        };
        findFirst: {
          args: Prisma.DataSourceConfigFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceConfigPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.DataSourceConfigFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceConfigPayload>;
        };
        findMany: {
          args: Prisma.DataSourceConfigFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceConfigPayload>[];
        };
        create: {
          args: Prisma.DataSourceConfigCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceConfigPayload>;
        };
        createMany: {
          args: Prisma.DataSourceConfigCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.DataSourceConfigCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceConfigPayload>[];
        };
        delete: {
          args: Prisma.DataSourceConfigDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceConfigPayload>;
        };
        update: {
          args: Prisma.DataSourceConfigUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceConfigPayload>;
        };
        deleteMany: {
          args: Prisma.DataSourceConfigDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.DataSourceConfigUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.DataSourceConfigUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceConfigPayload>[];
        };
        upsert: {
          args: Prisma.DataSourceConfigUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceConfigPayload>;
        };
        aggregate: {
          args: Prisma.DataSourceConfigAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateDataSourceConfig>;
        };
        groupBy: {
          args: Prisma.DataSourceConfigGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.DataSourceConfigGroupByOutputType>[];
        };
        count: {
          args: Prisma.DataSourceConfigCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.DataSourceConfigCountAggregateOutputType> | number;
        };
      };
    };
    ImportBatch: {
      payload: Prisma.$ImportBatchPayload<ExtArgs>;
      fields: Prisma.ImportBatchFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ImportBatchFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ImportBatchFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>;
        };
        findFirst: {
          args: Prisma.ImportBatchFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ImportBatchFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>;
        };
        findMany: {
          args: Prisma.ImportBatchFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>[];
        };
        create: {
          args: Prisma.ImportBatchCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>;
        };
        createMany: {
          args: Prisma.ImportBatchCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ImportBatchCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>[];
        };
        delete: {
          args: Prisma.ImportBatchDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>;
        };
        update: {
          args: Prisma.ImportBatchUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>;
        };
        deleteMany: {
          args: Prisma.ImportBatchDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ImportBatchUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ImportBatchUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>[];
        };
        upsert: {
          args: Prisma.ImportBatchUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>;
        };
        aggregate: {
          args: Prisma.ImportBatchAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateImportBatch>;
        };
        groupBy: {
          args: Prisma.ImportBatchGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ImportBatchGroupByOutputType>[];
        };
        count: {
          args: Prisma.ImportBatchCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ImportBatchCountAggregateOutputType> | number;
        };
      };
    };
    DataSourceRun: {
      payload: Prisma.$DataSourceRunPayload<ExtArgs>;
      fields: Prisma.DataSourceRunFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.DataSourceRunFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceRunPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.DataSourceRunFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceRunPayload>;
        };
        findFirst: {
          args: Prisma.DataSourceRunFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceRunPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.DataSourceRunFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceRunPayload>;
        };
        findMany: {
          args: Prisma.DataSourceRunFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceRunPayload>[];
        };
        create: {
          args: Prisma.DataSourceRunCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceRunPayload>;
        };
        createMany: {
          args: Prisma.DataSourceRunCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.DataSourceRunCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceRunPayload>[];
        };
        delete: {
          args: Prisma.DataSourceRunDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceRunPayload>;
        };
        update: {
          args: Prisma.DataSourceRunUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceRunPayload>;
        };
        deleteMany: {
          args: Prisma.DataSourceRunDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.DataSourceRunUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.DataSourceRunUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceRunPayload>[];
        };
        upsert: {
          args: Prisma.DataSourceRunUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DataSourceRunPayload>;
        };
        aggregate: {
          args: Prisma.DataSourceRunAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateDataSourceRun>;
        };
        groupBy: {
          args: Prisma.DataSourceRunGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.DataSourceRunGroupByOutputType>[];
        };
        count: {
          args: Prisma.DataSourceRunCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.DataSourceRunCountAggregateOutputType> | number;
        };
      };
    };
    ImportLog: {
      payload: Prisma.$ImportLogPayload<ExtArgs>;
      fields: Prisma.ImportLogFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ImportLogFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportLogPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ImportLogFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportLogPayload>;
        };
        findFirst: {
          args: Prisma.ImportLogFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportLogPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ImportLogFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportLogPayload>;
        };
        findMany: {
          args: Prisma.ImportLogFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportLogPayload>[];
        };
        create: {
          args: Prisma.ImportLogCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportLogPayload>;
        };
        createMany: {
          args: Prisma.ImportLogCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ImportLogCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportLogPayload>[];
        };
        delete: {
          args: Prisma.ImportLogDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportLogPayload>;
        };
        update: {
          args: Prisma.ImportLogUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportLogPayload>;
        };
        deleteMany: {
          args: Prisma.ImportLogDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ImportLogUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ImportLogUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportLogPayload>[];
        };
        upsert: {
          args: Prisma.ImportLogUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportLogPayload>;
        };
        aggregate: {
          args: Prisma.ImportLogAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateImportLog>;
        };
        groupBy: {
          args: Prisma.ImportLogGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ImportLogGroupByOutputType>[];
        };
        count: {
          args: Prisma.ImportLogCountArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ImportLogCountAggregateOutputType> | number;
        };
      };
    };
  };
} & {
  other: {
    payload: any;
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]];
        result: any;
      };
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]];
        result: any;
      };
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]];
        result: any;
      };
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]];
        result: any;
      };
    };
  };
};

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: "ReadUncommitted",
  ReadCommitted: "ReadCommitted",
  RepeatableRead: "RepeatableRead",
  Serializable: "Serializable",
} as const);

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

export const UserScalarFieldEnum = {
  id: "id",
  email: "email",
  name: "name",
  password: "password",
  role: "role",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

export const OrganizationScalarFieldEnum = {
  id: "id",
  name: "name",
  displayName: "displayName",
  description: "description",
  website: "website",
  logoUrl: "logoUrl",
  isActive: "isActive",
  onboardingCompletedAt: "onboardingCompletedAt",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum];

export const TeamScalarFieldEnum = {
  id: "id",
  name: "name",
  description: "description",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum];

export const TeamRepositoryScalarFieldEnum = {
  id: "id",
  teamId: "teamId",
  repositoryId: "repositoryId",
  createdAt: "createdAt",
} as const;

export type TeamRepositoryScalarFieldEnum = (typeof TeamRepositoryScalarFieldEnum)[keyof typeof TeamRepositoryScalarFieldEnum];

export const TeamProjectScalarFieldEnum = {
  id: "id",
  teamId: "teamId",
  projectId: "projectId",
  createdAt: "createdAt",
} as const;

export type TeamProjectScalarFieldEnum = (typeof TeamProjectScalarFieldEnum)[keyof typeof TeamProjectScalarFieldEnum];

export const RepositoryScalarFieldEnum = {
  id: "id",
  dataSourceId: "dataSourceId",
  name: "name",
  fullName: "fullName",
  description: "description",
  provider: "provider",
  url: "url",
  language: "language",
  stars: "stars",
  forks: "forks",
  isPrivate: "isPrivate",
  isArchived: "isArchived",
  defaultBranch: "defaultBranch",
  isEnabled: "isEnabled",
  lastSyncAt: "lastSyncAt",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type RepositoryScalarFieldEnum = (typeof RepositoryScalarFieldEnum)[keyof typeof RepositoryScalarFieldEnum];

export const ContributorScalarFieldEnum = {
  id: "id",
  name: "name",
  email: "email",
  username: "username",
  provider: "provider",
  providerUserId: "providerUserId",
  avatarUrl: "avatarUrl",
  userId: "userId",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type ContributorScalarFieldEnum = (typeof ContributorScalarFieldEnum)[keyof typeof ContributorScalarFieldEnum];

export const CommitScalarFieldEnum = {
  id: "id",
  sha: "sha",
  message: "message",
  authorId: "authorId",
  committedAt: "committedAt",
  repositoryId: "repositoryId",
  branch: "branch",
  linesAdded: "linesAdded",
  linesRemoved: "linesRemoved",
  filesChanged: "filesChanged",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type CommitScalarFieldEnum = (typeof CommitScalarFieldEnum)[keyof typeof CommitScalarFieldEnum];

export const PullRequestScalarFieldEnum = {
  id: "id",
  number: "number",
  title: "title",
  description: "description",
  state: "state",
  authorId: "authorId",
  assigneeId: "assigneeId",
  repositoryId: "repositoryId",
  sourceBranch: "sourceBranch",
  targetBranch: "targetBranch",
  url: "url",
  linesAdded: "linesAdded",
  linesRemoved: "linesRemoved",
  filesChanged: "filesChanged",
  commitsCount: "commitsCount",
  iterationCount: "iterationCount",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  mergedAt: "mergedAt",
  closedAt: "closedAt",
} as const;

export type PullRequestScalarFieldEnum = (typeof PullRequestScalarFieldEnum)[keyof typeof PullRequestScalarFieldEnum];

export const PullRequestReviewScalarFieldEnum = {
  id: "id",
  pullRequestId: "pullRequestId",
  reviewerId: "reviewerId",
  state: "state",
  body: "body",
  commentsCount: "commentsCount",
  submittedAt: "submittedAt",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type PullRequestReviewScalarFieldEnum = (typeof PullRequestReviewScalarFieldEnum)[keyof typeof PullRequestReviewScalarFieldEnum];

export const PipelineScalarFieldEnum = {
  id: "id",
  name: "name",
  provider: "provider",
  repositoryId: "repositoryId",
  configPath: "configPath",
  isActive: "isActive",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type PipelineScalarFieldEnum = (typeof PipelineScalarFieldEnum)[keyof typeof PipelineScalarFieldEnum];

export const PipelineRunScalarFieldEnum = {
  id: "id",
  pipelineId: "pipelineId",
  runNumber: "runNumber",
  status: "status",
  branch: "branch",
  commitSha: "commitSha",
  triggerEvent: "triggerEvent",
  url: "url",
  durationMs: "durationMs",
  startedAt: "startedAt",
  completedAt: "completedAt",
  errorMessage: "errorMessage",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type PipelineRunScalarFieldEnum = (typeof PipelineRunScalarFieldEnum)[keyof typeof PipelineRunScalarFieldEnum];

export const PipelineStageScalarFieldEnum = {
  id: "id",
  pipelineRunId: "pipelineRunId",
  name: "name",
  status: "status",
  durationMs: "durationMs",
  startedAt: "startedAt",
  completedAt: "completedAt",
  errorMessage: "errorMessage",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type PipelineStageScalarFieldEnum = (typeof PipelineStageScalarFieldEnum)[keyof typeof PipelineStageScalarFieldEnum];

export const QualityScanScalarFieldEnum = {
  id: "id",
  repositoryId: "repositoryId",
  branch: "branch",
  commitSha: "commitSha",
  coveragePercent: "coveragePercent",
  newCodeCoveragePercent: "newCodeCoveragePercent",
  technicalDebtRatio: "technicalDebtRatio",
  complexityScore: "complexityScore",
  codeSmellsCount: "codeSmellsCount",
  bugsCount: "bugsCount",
  vulnerabilitiesCount: "vulnerabilitiesCount",
  duplicatedLinesPercent: "duplicatedLinesPercent",
  maintainabilityRating: "maintainabilityRating",
  reliabilityRating: "reliabilityRating",
  securityRating: "securityRating",
  scannedAt: "scannedAt",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type QualityScanScalarFieldEnum = (typeof QualityScanScalarFieldEnum)[keyof typeof QualityScanScalarFieldEnum];

export const CoverageMetricScalarFieldEnum = {
  id: "id",
  qualityScanId: "qualityScanId",
  moduleOrPackage: "moduleOrPackage",
  coveragePercent: "coveragePercent",
  linesCovered: "linesCovered",
  linesTotal: "linesTotal",
  branchesPercent: "branchesPercent",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type CoverageMetricScalarFieldEnum = (typeof CoverageMetricScalarFieldEnum)[keyof typeof CoverageMetricScalarFieldEnum];

export const SecurityVulnerabilityScalarFieldEnum = {
  id: "id",
  repositoryId: "repositoryId",
  cveId: "cveId",
  title: "title",
  description: "description",
  severity: "severity",
  status: "status",
  affectedComponent: "affectedComponent",
  affectedVersion: "affectedVersion",
  fixedVersion: "fixedVersion",
  url: "url",
  discoveredAt: "discoveredAt",
  resolvedAt: "resolvedAt",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type SecurityVulnerabilityScalarFieldEnum = (typeof SecurityVulnerabilityScalarFieldEnum)[keyof typeof SecurityVulnerabilityScalarFieldEnum];

export const SonarQubeProjectMappingScalarFieldEnum = {
  id: "id",
  dataSourceId: "dataSourceId",
  projectKey: "projectKey",
  projectName: "projectName",
  repositoryId: "repositoryId",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type SonarQubeProjectMappingScalarFieldEnum = (typeof SonarQubeProjectMappingScalarFieldEnum)[keyof typeof SonarQubeProjectMappingScalarFieldEnum];

export const ProjectScalarFieldEnum = {
  id: "id",
  dataSourceId: "dataSourceId",
  name: "name",
  key: "key",
  description: "description",
  provider: "provider",
  url: "url",
  externalId: "externalId",
  isEnabled: "isEnabled",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum];

export const BoardScalarFieldEnum = {
  id: "id",
  projectId: "projectId",
  name: "name",
  externalId: "externalId",
  boardType: "boardType",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type BoardScalarFieldEnum = (typeof BoardScalarFieldEnum)[keyof typeof BoardScalarFieldEnum];

export const SprintScalarFieldEnum = {
  id: "id",
  projectId: "projectId",
  boardId: "boardId",
  name: "name",
  externalId: "externalId",
  goal: "goal",
  state: "state",
  startDate: "startDate",
  endDate: "endDate",
  completedAt: "completedAt",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type SprintScalarFieldEnum = (typeof SprintScalarFieldEnum)[keyof typeof SprintScalarFieldEnum];

export const IssueScalarFieldEnum = {
  id: "id",
  projectId: "projectId",
  boardId: "boardId",
  sprintId: "sprintId",
  key: "key",
  externalId: "externalId",
  title: "title",
  description: "description",
  type: "type",
  status: "status",
  statusName: "statusName",
  priority: "priority",
  assigneeId: "assigneeId",
  reporterId: "reporterId",
  storyPoints: "storyPoints",
  url: "url",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  resolvedAt: "resolvedAt",
} as const;

export type IssueScalarFieldEnum = (typeof IssueScalarFieldEnum)[keyof typeof IssueScalarFieldEnum];

export const IssueStatusTransitionScalarFieldEnum = {
  id: "id",
  issueId: "issueId",
  fromStatus: "fromStatus",
  toStatus: "toStatus",
  transitionedAt: "transitionedAt",
  authorId: "authorId",
  createdAt: "createdAt",
} as const;

export type IssueStatusTransitionScalarFieldEnum = (typeof IssueStatusTransitionScalarFieldEnum)[keyof typeof IssueStatusTransitionScalarFieldEnum];

export const DataSourceScalarFieldEnum = {
  id: "id",
  organizationId: "organizationId",
  name: "name",
  provider: "provider",
  description: "description",
  isEnabled: "isEnabled",
  syncIntervalMinutes: "syncIntervalMinutes",
  lastSyncAt: "lastSyncAt",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type DataSourceScalarFieldEnum = (typeof DataSourceScalarFieldEnum)[keyof typeof DataSourceScalarFieldEnum];

export const DataSourceConfigScalarFieldEnum = {
  id: "id",
  dataSourceId: "dataSourceId",
  key: "key",
  value: "value",
  isSecret: "isSecret",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type DataSourceConfigScalarFieldEnum = (typeof DataSourceConfigScalarFieldEnum)[keyof typeof DataSourceConfigScalarFieldEnum];

export const ImportBatchScalarFieldEnum = {
  id: "id",
  status: "status",
  triggeredBy: "triggeredBy",
  startedAt: "startedAt",
  completedAt: "completedAt",
  durationMs: "durationMs",
  totalScripts: "totalScripts",
  completedScripts: "completedScripts",
  failedScripts: "failedScripts",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type ImportBatchScalarFieldEnum = (typeof ImportBatchScalarFieldEnum)[keyof typeof ImportBatchScalarFieldEnum];

export const DataSourceRunScalarFieldEnum = {
  id: "id",
  dataSourceId: "dataSourceId",
  importBatchId: "importBatchId",
  status: "status",
  scriptName: "scriptName",
  recordsImported: "recordsImported",
  recordsFailed: "recordsFailed",
  startedAt: "startedAt",
  completedAt: "completedAt",
  durationMs: "durationMs",
  errorMessage: "errorMessage",
  lastFetchedDataAt: "lastFetchedDataAt",
  earliestFetchedDataAt: "earliestFetchedDataAt",
  metadata: "metadata",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type DataSourceRunScalarFieldEnum = (typeof DataSourceRunScalarFieldEnum)[keyof typeof DataSourceRunScalarFieldEnum];

export const ImportLogScalarFieldEnum = {
  id: "id",
  dataSourceRunId: "dataSourceRunId",
  level: "level",
  message: "message",
  details: "details",
  recordId: "recordId",
  createdAt: "createdAt",
} as const;

export type ImportLogScalarFieldEnum = (typeof ImportLogScalarFieldEnum)[keyof typeof ImportLogScalarFieldEnum];

export const SortOrder = {
  asc: "asc",
  desc: "desc",
} as const;

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

export const QueryMode = {
  default: "default",
  insensitive: "insensitive",
} as const;

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

export const NullsOrder = {
  first: "first",
  last: "last",
} as const;

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

/**
 * Field references
 */

/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "String">;

/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "String[]">;

/**
 * Reference to a field of type 'UserRole'
 */
export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "UserRole">;

/**
 * Reference to a field of type 'UserRole[]'
 */
export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "UserRole[]">;

/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "DateTime">;

/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "DateTime[]">;

/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Boolean">;

/**
 * Reference to a field of type 'VcsProvider'
 */
export type EnumVcsProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "VcsProvider">;

/**
 * Reference to a field of type 'VcsProvider[]'
 */
export type ListEnumVcsProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "VcsProvider[]">;

/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Int">;

/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Int[]">;

/**
 * Reference to a field of type 'PullRequestState'
 */
export type EnumPullRequestStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "PullRequestState">;

/**
 * Reference to a field of type 'PullRequestState[]'
 */
export type ListEnumPullRequestStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "PullRequestState[]">;

/**
 * Reference to a field of type 'ReviewState'
 */
export type EnumReviewStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "ReviewState">;

/**
 * Reference to a field of type 'ReviewState[]'
 */
export type ListEnumReviewStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "ReviewState[]">;

/**
 * Reference to a field of type 'CiProvider'
 */
export type EnumCiProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "CiProvider">;

/**
 * Reference to a field of type 'CiProvider[]'
 */
export type ListEnumCiProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "CiProvider[]">;

/**
 * Reference to a field of type 'PipelineStatus'
 */
export type EnumPipelineStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "PipelineStatus">;

/**
 * Reference to a field of type 'PipelineStatus[]'
 */
export type ListEnumPipelineStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "PipelineStatus[]">;

/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Float">;

/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Float[]">;

/**
 * Reference to a field of type 'VulnerabilitySeverity'
 */
export type EnumVulnerabilitySeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "VulnerabilitySeverity">;

/**
 * Reference to a field of type 'VulnerabilitySeverity[]'
 */
export type ListEnumVulnerabilitySeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "VulnerabilitySeverity[]">;

/**
 * Reference to a field of type 'VulnerabilityStatus'
 */
export type EnumVulnerabilityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "VulnerabilityStatus">;

/**
 * Reference to a field of type 'VulnerabilityStatus[]'
 */
export type ListEnumVulnerabilityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "VulnerabilityStatus[]">;

/**
 * Reference to a field of type 'ProjectProvider'
 */
export type EnumProjectProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "ProjectProvider">;

/**
 * Reference to a field of type 'ProjectProvider[]'
 */
export type ListEnumProjectProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "ProjectProvider[]">;

/**
 * Reference to a field of type 'IssueType'
 */
export type EnumIssueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "IssueType">;

/**
 * Reference to a field of type 'IssueType[]'
 */
export type ListEnumIssueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "IssueType[]">;

/**
 * Reference to a field of type 'IssueStatus'
 */
export type EnumIssueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "IssueStatus">;

/**
 * Reference to a field of type 'IssueStatus[]'
 */
export type ListEnumIssueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "IssueStatus[]">;

/**
 * Reference to a field of type 'IssuePriority'
 */
export type EnumIssuePriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "IssuePriority">;

/**
 * Reference to a field of type 'IssuePriority[]'
 */
export type ListEnumIssuePriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "IssuePriority[]">;

/**
 * Reference to a field of type 'DataSourceProvider'
 */
export type EnumDataSourceProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "DataSourceProvider">;

/**
 * Reference to a field of type 'DataSourceProvider[]'
 */
export type ListEnumDataSourceProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "DataSourceProvider[]">;

/**
 * Reference to a field of type 'DataSourceRunStatus'
 */
export type EnumDataSourceRunStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "DataSourceRunStatus">;

/**
 * Reference to a field of type 'DataSourceRunStatus[]'
 */
export type ListEnumDataSourceRunStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "DataSourceRunStatus[]">;

/**
 * Reference to a field of type 'ImportLogLevel'
 */
export type EnumImportLogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "ImportLogLevel">;

/**
 * Reference to a field of type 'ImportLogLevel[]'
 */
export type ListEnumImportLogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "ImportLogLevel[]">;

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number;
};

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>;
export type DefaultPrismaClient = PrismaClient;
export type ErrorFormat = "pretty" | "colorless" | "minimal";
export type PrismaClientOptions = (
  | {
      /**
       * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
       */
      adapter: runtime.SqlDriverAdapterFactory;
      accelerateUrl?: never;
    }
  | {
      /**
       * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
       */
      accelerateUrl: string;
      adapter?: never;
    }
) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat;
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   *
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   *
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   *
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[];
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number;
    timeout?: number;
    isolationLevel?: TransactionIsolationLevel;
  };
  /**
   * Global configuration for omitting model fields by default.
   *
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig;
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   *
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[];
};
export type GlobalOmitConfig = {
  user?: Prisma.UserOmit;
  organization?: Prisma.OrganizationOmit;
  team?: Prisma.TeamOmit;
  teamRepository?: Prisma.TeamRepositoryOmit;
  teamProject?: Prisma.TeamProjectOmit;
  repository?: Prisma.RepositoryOmit;
  contributor?: Prisma.ContributorOmit;
  commit?: Prisma.CommitOmit;
  pullRequest?: Prisma.PullRequestOmit;
  pullRequestReview?: Prisma.PullRequestReviewOmit;
  pipeline?: Prisma.PipelineOmit;
  pipelineRun?: Prisma.PipelineRunOmit;
  pipelineStage?: Prisma.PipelineStageOmit;
  qualityScan?: Prisma.QualityScanOmit;
  coverageMetric?: Prisma.CoverageMetricOmit;
  securityVulnerability?: Prisma.SecurityVulnerabilityOmit;
  sonarQubeProjectMapping?: Prisma.SonarQubeProjectMappingOmit;
  project?: Prisma.ProjectOmit;
  board?: Prisma.BoardOmit;
  sprint?: Prisma.SprintOmit;
  issue?: Prisma.IssueOmit;
  issueStatusTransition?: Prisma.IssueStatusTransitionOmit;
  dataSource?: Prisma.DataSourceOmit;
  dataSourceConfig?: Prisma.DataSourceConfigOmit;
  importBatch?: Prisma.ImportBatchOmit;
  dataSourceRun?: Prisma.DataSourceRunOmit;
  importLog?: Prisma.ImportLogOmit;
};

/* Types for Logging */
export type LogLevel = "info" | "query" | "warn" | "error";
export type LogDefinition = {
  level: LogLevel;
  emit: "stdout" | "event";
};

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<T extends LogDefinition ? T["level"] : T>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

export type QueryEvent = {
  timestamp: Date;
  query: string;
  params: string;
  duration: number;
  target: string;
};

export type LogEvent = {
  timestamp: Date;
  message: string;
  target: string;
};
/* End Types for Logging */

export type PrismaAction =
  | "findUnique"
  | "findUniqueOrThrow"
  | "findMany"
  | "findFirst"
  | "findFirstOrThrow"
  | "create"
  | "createMany"
  | "createManyAndReturn"
  | "update"
  | "updateMany"
  | "updateManyAndReturn"
  | "upsert"
  | "delete"
  | "deleteMany"
  | "executeRaw"
  | "queryRaw"
  | "aggregate"
  | "count"
  | "runCommandRaw"
  | "findRaw"
  | "groupBy";

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>;
